<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Code Life]]></title>
  <link href="http://blog.code-life.net/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://blog.code-life.net/"/>
  <updated>2014-09-23T22:14:12+09:00</updated>
  <id>http://blog.code-life.net/</id>
  <author>
    <name><![CDATA[noto]]></name>
    <email><![CDATA[noto.code.life@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[php array_flattenを実装する]]></title>
    <link href="http://blog.code-life.net/blog/2014/09/23/php-array-flatten/"/>
    <updated>2014-09-23T21:24:42+09:00</updated>
    <id>http://blog.code-life.net/blog/2014/09/23/php-array-flatten</id>
    <content type="html"><![CDATA[<p>phpは配列を操作する関数が多くあるが多次元配列をフラットにする関数がない。(ということを最近知った)</p>

<p>実装方法は様々あるが、その中からいくつか紹介します。</p>

<!--more-->


<h2>再帰的に処理をする</h2>

<pre><code class="php">function array_flatten(array $arr) {
    $ret = array();

    foreach ($arr as $item) {
        if (is_array($item)) {
            $ret = array_merge($ret, array_flatten($item));
        } else {
            $ret[] = $item;
        }
    }

    return $ret;
}
</code></pre>

<h2>SPLのイテレータクラスを利用する</h2>

<pre><code class="php">function array_flatten(array $arr) {
    return iterator_to_array(new RecursiveIteratorIterator(new RecursiveArrayIterator($arr)), false);
}
</code></pre>

<p>値に対して何らかの処理を行いたい場合はこちらのほうが良いかも。</p>

<pre><code>function array_flatten(array $arr) {
    $it = new RecursiveIteratorIterator(new RecursiveArrayIterator($arr));

    $ret = array();

    foreach ($it as $value) {
        $ret[] = $value;
    }

    return $ret;
}
</code></pre>

<p>SPLのイテレータクラス初めて知ったけどシンプルに書けてよいね。</p>

<h2>参考</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/1319903/how-to-flatten-a-multidimensional-array">How to Flatten a Multidimensional Array?</a></li>
<li><a href="http://yuubiseiharukana.blog.shinobi.jp/Entry/1156/">PHP5.4.7 PHPでarray_flatten関数のパフォーマンス測定</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CakePHP2.x クエリーログを取得する]]></title>
    <link href="http://blog.code-life.net/blog/2014/08/29/how-to-get-query-log-in-cakephp2/"/>
    <updated>2014-08-29T10:58:40+09:00</updated>
    <id>http://blog.code-life.net/blog/2014/08/29/how-to-get-query-log-in-cakephp2</id>
    <content type="html"><![CDATA[<p>どんなクエリが発行されているか確認したい場合があった際のメモ</p>

<!--more-->


<h2>環境</h2>

<ul>
<li>CakePHP 2.5.2</li>
<li>MySQL 5.5.30</li>
</ul>


<h2>注意</h2>

<p>この方法でクエリーログが取得できるのはデバッグレベル2の場合のみ</p>

<h2>クエリーログを取得する</h2>

<pre><code class="php">$log = $this-&gt;{$Model}-&gt;getDataSource()-&gt;getLog(false, false);
</code></pre>

<ul>
<li>第１引数は、ソートの有無。trueの場合はtook(ms)で降順ソート</li>
<li>第2引数では、クエリーを格納している変数の初期化を行うか否か</li>
</ul>


<h3>返却値</h3>

<p>以下のデータ構造で返却される。</p>

<pre><code class="php sample value">Array
(
    [log] =&gt; Array
        (
            [0] =&gt; Array
                (
                    [query] =&gt; SELECT `username` FROM `users`  AS `User`
                    [params] =&gt; Array
                        (
                        )

                    [affected] =&gt; 1
                    [numRows] =&gt; 1
                    [took] =&gt; 1
                )

            [1] =&gt; Array
                (
                    [query] =&gt; SELECT `name` FROM `groups`  AS `Group`
                    [params] =&gt; Array
                        (
                        )

                    [affected] =&gt; 1
                    [numRows] =&gt; 1
                    [took] =&gt; 0
                )
        )

    [count] =&gt; 2
    [time] =&gt; 1
)
</code></pre>

<p><code>getLog</code>が行っている処理内容</p>

<pre><code class="php lib/Cake/Model/Datasource/DboSource.php">/**
 * Get the query log as an array.
 *
 * @param boolean $sorted Get the queries sorted by time taken, defaults to false.
 * @param boolean $clear If True the existing log will cleared.
 * @return array Array of queries run as an array
 */
public function getLog($sorted = false, $clear = true) {
    if ($sorted) {
        $log = sortByKey($this-&gt;_queriesLog, 'took', 'desc', SORT_NUMERIC);
    } else {
        $log = $this-&gt;_queriesLog;
    }
    if ($clear) {
        $this-&gt;_queriesLog = array();
    }
    return array('log' =&gt; $log, 'count' =&gt; $this-&gt;_queriesCnt, 'time' =&gt; $this-&gt;_queriesTime);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Slim Framework]サブディレクトリにインストールした場合のリダイレクト方法]]></title>
    <link href="http://blog.code-life.net/blog/2014/01/06/redirecting-slim-application-from-subdirectory/"/>
    <updated>2014-01-06T22:07:00+09:00</updated>
    <id>http://blog.code-life.net/blog/2014/01/06/redirecting-slim-application-from-subdirectory</id>
    <content type="html"><![CDATA[<p>簡単なWebアプリを作る機会があったので、PHPのマイクロフレームワークの一つである<a href="http://docs.slimframework.com">Slim Framework</a>を触ってみた。</p>

<p>そこでサブディレクトリにインストールした場合のリダイレクト方法で少しハマったので共有しておく。</p>

<!--more-->


<h2>環境</h2>

<p>Slim 2.4.0</p>

<h2>getRootUriを利用する</h2>

<p>Slim_Http_Request::getRootUriはサブディレクトリ名を返すのでそれを利用しリダイレクトを行う。</p>

<p>ex) サブディレクトリ名がslimの場合、「/slim」という文字列を返す。</p>

<pre><code class="php">$app-&gt;get('/index',  function () use ($app) {
    $app-&gt;redirect($app-&gt;request-&gt;getRootUri() . '/hoge' );
}
</code></pre>

<h2>urlForを利用する</h2>

<p>Slimはrouteに任意の名前を割り当てることができ、urlForでURLを生成することができる。</p>

<pre><code class="php">$app-&gt;get('/index',  function () use ($app) {
    $app-&gt;render('index.php');
})-&gt;name('index');

$app-&gt;get('/edit',  function () use ($app) {
    $app-&gt;redirect($app-&gt;urlFor('index'));
}
</code></pre>

<p>これでインストール先がドキュメントルートだろうが、サブディレクトリだろうがコードを変える必要はなくなる。</p>

<h2>参考</h2>

<p><a href="http://docs.slimframework.com/#Route-Names">Slim Framework Documentation</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[php]連想配列を特定のキーの同じ値でグルーピング]]></title>
    <link href="http://blog.code-life.net/blog/2013/12/18/php-group-array-by-value/"/>
    <updated>2013-12-18T22:36:00+09:00</updated>
    <id>http://blog.code-life.net/blog/2013/12/18/php-group-array-by-value</id>
    <content type="html"><![CDATA[<p>連想配列を特定キーの同じ値でグルーピングする方法。</p>

<!--more-->


<pre><code class="php">&lt;?php

$arr = array(
    array(
        'name' =&gt; 'yamada',
        'age'  =&gt; '20'
    ),
    array(
        'name' =&gt; 'satou',
        'age'  =&gt; '20'
    ),
    array(
        'name' =&gt; 'suzuki',
        'age'  =&gt; '30'
    ),
    array(
        'name' =&gt; 'tanaka',
        'age'  =&gt; '40'
    )
);


function groupArray($arr, $key) {
    $retval = array();

    foreach($arr as $value) {
        $group = $value[$key];

        if (!isset($retval[$group])) {
            $retval[$group] = array();
        }

        $retval[$group][] = $value;
    }

    return $retval;
}

var_dump(groupArray($arr, 'age'));
</code></pre>

<h3>結果</h3>

<pre><code class="php">
array(3) {
  [20]=&gt;
  array(2) {
    [0]=&gt;
    array(2) {
      ["name"]=&gt;
      string(6) "yamada"
      ["age"]=&gt;
      string(2) "20"
    }
    [1]=&gt;
    array(2) {
      ["name"]=&gt;
      string(5) "satou"
      ["age"]=&gt;
      string(2) "20"
    }
  }
  [30]=&gt;
  array(1) {
    [0]=&gt;
    array(2) {
      ["name"]=&gt;
      string(6) "suzuki"
      ["age"]=&gt;
      string(2) "30"
    }
  }
  [40]=&gt;
  array(1) {
    [0]=&gt;
    array(2) {
      ["name"]=&gt;
      string(6) "tanaka"
      ["age"]=&gt;
      string(2) "40"
    }
  }
}
</code></pre>

<p>ageキーの同じ値でグルーピングされていることが確認できます。そもそも(ry</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[CakePHP]モデルのコールバックを無効化にする]]></title>
    <link href="http://blog.code-life.net/blog/2013/09/25/cakephp-model-callback/"/>
    <updated>2013-09-25T21:59:00+09:00</updated>
    <id>http://blog.code-life.net/blog/2013/09/25/cakephp-model-callback</id>
    <content type="html"><![CDATA[<p>モデルの<a href="http://book.cakephp.org/2.0/ja/models/callback-methods.html">コールバックメソッド</a>が様々ありますが、無効化したい場合があります。</p>

<p>find, save共に第２引数にcallbacksをキーとした配列を渡すことでモデルのコールバック実行の可否を伝えることが可能です。</p>

<!--more-->


<h2>find(beforeFind, afterFind共に無効化)</h2>

<pre><code class="php">$this-&gt;find('first', array(
    'callbacks' =&gt; false
));
</code></pre>

<h2>find(beforeFindのみ有効)</h2>

<pre><code class="php">$this-&gt;find('first', array(
    'callbacks' =&gt; 'before'
));
</code></pre>

<h2>find(afterFindのみ有効)</h2>

<pre><code class="php">$this-&gt;find('first', array(
    'callbacks' =&gt; 'after'
));
</code></pre>

<h2>save(beforeSave, afterSave共に無効化)</h2>

<pre><code class="php">$this-&gt;save($data, array(
    'callbacks' =&gt; false
));
</code></pre>

<h2>save(beforeSaveのみ有効)</h2>

<pre><code class="php">$this-&gt;save($data, array(
    'callbacks' =&gt; 'before'
));
</code></pre>

<h2>save(afterSaveのみ有効)</h2>

<pre><code class="php">$this-&gt;save($data, array(
    'callbacks' =&gt; 'after'
));
</code></pre>

<p>という小ネタ。</p>
]]></content>
  </entry>
  
</feed>
